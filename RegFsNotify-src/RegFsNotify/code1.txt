
// QueryKey() - Enumerates the subkeys of key and its associated values.
//     hKey   - Key whose subkeys and values are to be enumerated.
// #define _WIN32_WINNT 0x0502   // Windows Server 2003 family
// For Win Xp, change accordingly...

#define _WIN32_WINNT 0x0501
// #define _WIN32_WINNT 0x0500   // Windows 2000
// #define _WIN32_WINNT 0x0400   // Windows NT 4.0
// #define _WIN32_WINDOWS 0x0500 // Windows ME
// #define _WIN32_WINDOWS 0x0410 // Windows 98
// #define _WIN32_WINDOWS 0x0400 // Windows 95

#include <windows.h>
#include <stdio.h>

#define MAX_KEY_LENGTH 255
#define MAX_VALUE_NAME 16383

void QueryKey(HKEY hKey)
{

	CHAR     achKey[MAX_KEY_LENGTH];	// buffer for subkey name
	DWORD    cbName;					// size of name string
	CHAR     achClass[MAX_PATH] = "";	// buffer for class name
	DWORD    cchClassName = MAX_PATH;	// size of class string
	DWORD    cSubKeys=0;				// number of subkeys
	DWORD    cbMaxSubKey;				// longest subkey size
	DWORD    cchMaxClass;				// longest class string
	DWORD    cValues;					// number of values for key
	DWORD    cchMaxValue;				// longest value name
	DWORD    cbMaxValueData;			// longest value data
	DWORD    cbSecurityDescriptor;		// size of security descriptor
	FILETIME ftLastWriteTime;			// last write time 
	DWORD i, retCode;
	CHAR  achValue[MAX_VALUE_NAME];
	DWORD cchValue = MAX_VALUE_NAME;
	// Get the class name and the value count.

	retCode = RegQueryInfoKey(
		hKey,							// key handle
		achClass,						// buffer for class name
		&cchClassName,					// size of class string
		NULL,							// reserved
		&cSubKeys,						// number of subkeys
		&cbMaxSubKey,					// longest subkey size 
		&cchMaxClass,					// longest class string 
		&cValues,						// number of values for this key 
		&cchMaxValue,					// longest value name 
		&cbMaxValueData,				// longest value data  
		&cbSecurityDescriptor,			// security descriptor 
		&ftLastWriteTime);				// last write time 

	// Enumerate the subkeys, until RegEnumKeyEx() fails.
	if(cSubKeys)
	{
		printf("Subkey Names:\n");
		for(i=0; i<cSubKeys; i++) 
		{
			cbName = MAX_KEY_LENGTH;
			retCode = RegEnumKeyEx(
				hKey,					// Handle to an open/predefined key
				i,						// Index of the subkey to retrieve.
				achKey,					// buffer that receives the name of the subkey
				&cbName,				// size of the buffer specified by the achKey
				NULL,					// Reserved; must be NULL 
				NULL,					// buffer that receives the class string  of the enumerated subkey 
				NULL,					// size of the buffer specified by the previous parameter 
				&ftLastWriteTime		// variable that receives the time at which  the enumerated subkey was last written
				);
			if(retCode == ERROR_SUCCESS)  
			{ printf("(%d) %s\n", i+1, achKey); }
		}
		printf("Number of subkeys: %d\n\n", cSubKeys);
	}
	else
		printf("RegEnumKeyEx(), there is no subkey.\n");

	// Enumerate the key values if any.
	if(cValues) 
	{
		for(i=0, retCode=ERROR_SUCCESS; i<cValues; i++) 
		{
			cchValue = MAX_VALUE_NAME; 
			achValue[0] = '\0';
			retCode = RegEnumValue(
				hKey,					// Handle to an open key
				i,                      // Index of value
				achValue,				// Value name 
				&cchValue,				// Buffer for value name
				NULL,					// Reserved
				NULL,					// Value type
				NULL,					// Value data
				NULL);					// Buffer for value data

			if(retCode == ERROR_SUCCESS)
			{ printf("(%d) Value Name: %s.\n", i+1, achValue); }
		}
		printf("Number of values: %d\n", cValues);
	}
	else
		printf("No value under this key/subkey...\n");     
}

int main(int argc, char *argv[ ])
{
	// Change the key and subkey accordingly...
	// Predefined registry keys:
	// HKEY_CLASSES_ROOT
	// HKEY_CURRENT_CONFIG
	// HKEY_CURRENT_USER
	// HKEY_LOCAL_MACHINE
	// HKEY_PERFORMANCE_DATA
	// HKEY_USERS

	//*************** open key (and subkey) ******************

	HKEY theKey = HKEY_CURRENT_USER;   // Key, change accordingly...
	HKEY hKey;															// Key and subkey
	LONG lRet = RegOpenKeyEx(
		theKey,															// Key
		"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RUN",			// Subkey, change accordingly
		0,                                                              // Reserved
		KEY_ALL_ACCESS,													// desired access rights to the key
		&hKey);															// variable that receives a handle to the opened key
	if(lRet == ERROR_SUCCESS)
		printf("RegOpenKeyEx() is OK.\n");
	else
		printf("RegOpenKeyEx() is not OK.\n");
	QueryKey(hKey);
	RegCloseKey(hKey);
	return 0;
}
